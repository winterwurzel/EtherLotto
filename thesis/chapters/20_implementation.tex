%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}\label{chap:impl}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapterstart


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ Smart Contract with Solidity}\label{sec:solidity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The implementation of the Ethereum Smart Contract can be done in various programming languages. However, the most common and well documented one is Solidity and was therefore chosen for this project work.

Solidity is a contract-oriented, high-level language for implementing smart contracts. It was influenced by C++, Python and JavaScript and is designed to target the \ac{EVM}.

Solidity is statically typed, supports inheritance, libraries and complex user-defined types among other features.


A simple Example in Solidity:
\begin{lstlisting}[language=Solidity]
pragma solidity ^0.4.0; // defines the solidity version

contract SimpleStorage { // = collection of functions and data
    uint storedData; // unsigned integer variable

    // public setter
    function set(uint x) public {
        storedData = x;
    }

    // public getter
    function get() public constant returns (uint) {
        return storedData;
    }
}
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Lottery States}\label{sec:states}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A lottery usually goes through several states. From the start of the lottery, where bids are accepted, to the drawing of the winner and payout of the sum won.

Therefore in Solidity the following states where defined using Enums:

\begin{lstlisting}[language=Solidity]
// This is the current state.
States private state = States.AcceptingBids;

    enum States {
    AcceptingBids,
    ChooseWinner,
    Reset
}
\end{lstlisting}

An Enum is a way in Solidity to create a user-defined type. They are explicitly convertible to and from all integer types but implicit conversion is not allowed. The explicit conversions check the value ranges at runtime and a failure causes an exception. Enums needs at least one member.

Based on these Enums and the variable state, it is possible to determine the current state of the Lottery and make only specific function available.

To transition between these states, custom function modifiers can be created. These modifiers not only handle the transition between states, but also restrict access to functions not allowed in the current state.

\begin{lstlisting}[language=Solidity]
// modifier to restrict access
modifier atState(States _state) {
    // throws exception if condition not met
    require(state == _state);
    
    // code from the function being modified is inserted here
    _;
}

// function so set the next state
function nextState() internal {
    // increment state by 1
    state = States(uint(state) + 1);
}

// modifier to trasition to the next state after function execution
modifier transitionNext() {
    // code from the function being modified is inserted here
    _;
    
    nextState();
}

// transistion modifier with time condition
modifier timedTransitions() {
    if (state == States.AcceptingBids && now >= creationTime + duration)
        nextState();
        
    // code from the function being modified is inserted here
    _;
}
\end{lstlisting}

A modifier can then simply be added to a function declaration.

\begin{lstlisting}[language=Solidity]
// only possible to call when state = Reset
function clear() public atState(States.Reset) {
    playerIndex = 0;
    players.length = 0;
    winnerIndex = 0;
    winners.length = 0;
    state = States.AcceptingBids;
    creationTime = now;
}
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Player and Winner data struct}\label{sec:structs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To save players, determine winners and in turn also save them, custom data types where necessary.

In Solidity this can be realized via Structs and is somewhat similar to Structs in C/C++.

\begin{lstlisting}[language=Solidity]
struct Player {
    address id; // Ethereum address
    uint index; // player index
    uint luckyNumber; // number the player bet on
}

// array of players
Player[] private players;
uint private playerIndex = 0;

// array of winners in the current round
Player[] private winners;
uint private winnerIndex = 0;


struct PastWinner {
    Player player; // the player who won
    uint amount; // the amount won
    uint winningTime; // the time the player won
}

// array of all-time winners
PastWinner[] private pastWinners;
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Events}\label{sec:events}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Events allow the convenient usage of the \ac{EVM} logging facilities, which in turn can be used to trigger JavaScript callbacks in the user interface of a \ac{DApp}, which listen for these events.

However, in this Project Work Events are simply used to log relevent information.


\begin{lstlisting}[language=Solidity]
// event declaration
event NewBidRecieved(address id, uint index, uint amount, uint luckyNumber);
event CalculatedNewRandom(uint random);
event StateChanged(States state);


function nextState() internal {
    state = States(uint(state) + 1);
    // trigger event
    StateChanged(state);
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Placing a bid}\label{sec:bet}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following function can be called to place a new bid:

\begin{lstlisting}[language=Solidity]
function bid(uint _luckyNumber) public payable timedTransitions atState(States.AcceptingBids) {
    // check correct amount sent
    require(msg.value == bidSize);
    // check numbe rin range
    require(_luckyNumber != 0 && _luckyNumber < (maximum + 1)); 

    // trigger event
    NewBidRecieved(msg.sender, playerIndex, msg.value, _luckyNumber);

    // add amount sent to pot size
    pot += msg.value;
    // add new player to array
    insertPlayer(Player(msg.sender, playerIndex, _luckyNumber));
}
\end{lstlisting}

The modifier payable indicates that this function can recieve ether, timedTransitions and atState are explained in Section~\ref{sec:states}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Random Generation}\label{sec:random}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A random Generation in a deterministic Blockchain like the one Ethereum uses is impossible. Therefore the random number is calculated from the bblockhash of the next block generated after the state of the changed to ChooseWinner. In this state no additional bids are accepted. This method of calculating a pseudo-random number is potentially manipulateable, because a miner controlling about 50\% the Ethereum hash calculation could influence the next blockhash by invalidating the calculated block if he chooses. Since this magnitude of manipulation is extremely resource heavy, it is no feasable to use it for such small amounts of Ether used in this demo /ac{DApp}.

Function to get the pseudo-random number:
\begin{lstlisting}[language=Solidity]
function getRandom(uint _maximum) public view returns (uint random) {
    return uint(block.blockhash(block.number-1)) % _maximum + 1;
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Choosing a Winner}\label{sec:winner}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following snippet chooses all winners for a lottery round and lets them withdraw their share of the pot.

\begin{lstlisting}[language=Solidity]
function chooseWinner() public timedTransitions atState(States.ChooseWinner) {
    // get random number
    uint winningNumber = getRandom(maximum);

    // trigger event
    CalculatedNewRandom(winningNumber);

    // get winners and insert them into winners array
    getWinners(winningNumber);

    if (winners.length > 0) {
        // set the amount each winner can withdraw
        setPendingWithdrawals();
    }

    // transition to Reset state
    nextState();
    clear();
}

function getWinners(uint winningNumber) internal {
    for (uint i = 0; i < playerIndex; i++) {
        if (players[i].luckyNumber == winningNumber) {
            insertWinner(players[i]);
        }
    }
}

function setPendingWithdrawals() internal {
    uint potPerWinner = pot / winners.length;
    pot = 0;

    for (uint i = 0; i < winnerIndex; i++) {
        pendingWithdrawals[winners[i].id] += potPerWinner;
        pastWinners.push(PastWinner(winners[i], potPerWinner, now));
    }
}
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Withdrawing Ether}\label{sec:withdraw}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The recommended method of sending funds after an effect is using the withdrawal pattern. Although the most intuitive method of sending Ether, as a result of an effect, is a direct send call, this is not recommended as it introduces a potential security risk.

\begin{lstlisting}[language=Solidity]
function withdraw() public {
    uint amount = pendingWithdrawals[msg.sender];
    // Remember to zero the pending refund before
    // sending to prevent re-entrancy attacks
    pendingWithdrawals[msg.sender] = 0;
    msg.sender.transfer(amount);
}
\end{lstlisting}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{User Interface with Truffle Framework}\label{sec:truffle}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tests with Truffle Framework}\label{sec:truffleTest}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Solidity Tests}\label{sec:solTest}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Javascript Tests}\label{sec:jsTest}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapterend

